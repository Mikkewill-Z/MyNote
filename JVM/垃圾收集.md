主要是针对堆[[JVM#^0525d9]]和方法区[[JVM#^dcfa08]]进行.^[程序计数器,虚拟机栈和本地方法栈三个区域属于线程私有的,只存在于线程的生命周期内,线程结束之后就会消失,因此不需要对这三个区域进行垃圾回收.]

# 判断一个对象是否可被回收
## 1.引用计数算法
为对象添加⼀个引⽤计数器，当对象增加⼀个引⽤时计数器加 1，引⽤失效时计数器减 1。引⽤计数为 0 的 对象可被回收。 在两个对象出现循环引⽤的情况下，此时引⽤计数器永远不为 0，导致⽆法对它们进⾏回收。正是因为循环 引⽤的存在，因此 Java 虚拟机不使⽤引⽤计数算法。
## 2.可达性分析算法
以 GC Roots 为起始点进⾏搜索，可达的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使⽤该算法来判断对象是否可被回收，GC Roots ⼀般包含以下内容：
- 虚拟机栈中局部变量表中引用的对象
- 本地方法栈中JNI中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象
## 3.方法区的回收
^1bdbd2
因为⽅法区主要存放永久代对象，⽽永久代对象的回收率⽐新⽣代低很多，所以在⽅法区上进⾏回收性价⽐不⾼。^[主要是对常量池的回收和对类的卸载]
为了避免内存溢出，在⼤量使⽤反射和动态代理的场景都需要虚拟机具备类卸载功能。 类的卸载条件很多，需要满⾜以下三个条件，并且满⾜了条件也不⼀定会被卸载： 
- 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 Class 对象没有在任何地⽅被引⽤，也就⽆法在任何地⽅通过反射访问该类⽅法。
## 4.finalize()
类似C++的析构函数,用于关闭外部资源.^[但是try_finally等方式可以更好,且该方法运行代价很高,不确定性大,无法保证各个对象的调用顺序,最好不要使用.]
当⼀个对象可被回收时，如果需要执⾏该对象的 finalize() ⽅法，那么就有可能在该⽅法中让对象重新被引 ⽤，从⽽实现⾃救。⾃救只能进⾏⼀次，如果回收的对象之前调⽤了 finalize() ⽅法⾃救，后⾯回收时不会 再调⽤该⽅法。
# 引用类型
⽆论是通过引⽤计数算法判断对象的引⽤数量，还是通过可达性分析算法判断对象是否可达，判定对象是否 可被回收都与引⽤有关。
## 1. 强引用
被强引⽤关联的对象不会被回收。 
使⽤ new ⼀个新对象的⽅式来创建强引⽤。
## 2. 软引用
被软引⽤关联的对象只有在内存不够的情况下才会被回收。
使⽤ SoftReference 类来创建软引⽤。
```
Object obj = new Object(); 
SoftReference sf = new SoftReference<Object>(obj);
obj = null; // 使对象只被软引⽤关联
```
## 3. 弱引用
被弱引⽤关联的对象⼀定会被回收，也就是说它只能存活到下⼀次垃圾回收发⽣之前。
使⽤ WeakReference 类来创建弱引⽤。
```
Object obj = new Object();
WeakReference wf = new WeakReference<Object>(obj);
obj = null;
```
## 4. 虚引用
⼜称为幽灵引⽤或者幻影引⽤，⼀个对象是否有虚引⽤的存在，不会对其⽣存时间造成影响，也⽆法通过虚 引⽤得到⼀个对象。
为⼀个对象设置虚引⽤的唯⼀⽬的是能在这个对象被回收时收到⼀个系统通知。
使⽤ PhantomReference 来创建虚引⽤。
```
Object obj = new Object();
PhantomReference pf = newPhantomReference(obj, null);
obj = null;
```
# 垃圾收集算法
1.标记-清除
2.标记-整理
3.复制
4.分代收集
# 垃圾收集器
1.Serial收集器
2.ParNew收集器
3.Parallel Scavenge收集器
4.SerialOld收集器
5.ParallelOld收集器
6.CMS收集器
7.G1收集器
