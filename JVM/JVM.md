2023-11-20
[[JVMquestion]]
## JVM体系结构

![[Pasted image 20231120114111.png]]

方法区 : 存储已被虚拟机加载的类元数据信息(元空间)

堆 : 存放对象实例,几乎所有的对象实例都在这里进行内存的分配

虚拟机栈: 虚拟机栈描述的是**Java方法执行的内存模型**：每个方法被执行的时候都会同时创建一个**栈帧**（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息

程序计数器：当前线程所执行的字节码的**行号指示器**,也叫程序计数器

本地方法栈：本地方法栈则是为虚拟机使用到的**Native方法服务**。
# 运行时数据区

**程序计数器(PC)**: 记录正在执行的虚拟机字节码指令的地址(如果正在执行的时本地方法则为空).

**java虚拟机栈**: 每个java方法在执行的同时都会创建一个栈帧来存储局部变量表,操作数栈,常量池引用等信息.从方法调用直至执行完成的过程,对应着一个栈帧在java虚拟机栈中入栈和出栈的过程

**本地方法栈**: 本地方法栈与java虚拟机栈类似,它们之间的区别只不过时本地方法栈为本地方法服务.一般是其他语言编写

**堆**: 所有的对象都在这里进行内存的分配,是 [[垃圾收集]] 的主要区域.(GC堆),
		现代垃圾收集器基本采用 分代收集算法 ,主要是针对不同类型的对象采取不同的垃圾回收算法.   可以将堆分成两块:     新生代(Young Generation)  老生代(Old Generation) ^0525d9

**方法区**: 用于存放已被加载的类信息,常量,静态变量,即时编译器(JIT)编译后的代码等数据
		和堆一样不需要连续的内存且允许动态生成 
		^[对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载
		HotSpot 虚拟机把它当成永久代来进行垃圾回收,但是很难确定永久代大小,每次FullGc之后永久代的大小都会发生变化.
		从JDK1.8开始,移除了永久代,并把方法区移至元空间,它位于本地内存之中,而不是虚拟机内存之中.]
		[[垃圾收集#^1bdbd2]]
		
**运行时常量池**: 运行时常量池是方法区的一部分,Class文件中的常量池会在类加载后被放入这个区域,允许动态生成. ^dcfa08

**直接内存**: 在JDK1.4中更新引入了NIO类,可以使用本地函数库直接分配堆外内存,然后通过java堆内的DirectByteBuffer 对象作为这块内存的引⽤进⾏操作。^[避免了在堆内存和堆外内存来回拷贝数据]





