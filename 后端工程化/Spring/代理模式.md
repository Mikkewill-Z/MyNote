![[Pasted image 20231127160958.png|500]]
# 介绍
给真实对象生成代理对象,若是需要对真实对象进行调用时,借助代理类作为中间件,先调用代理对象,代理对象再调用真实对象.
# 分类
## 静态代理
新建一代理类
在代理类中将被代理的目标对象声明为成员变量
随后在具体的调用方法中加入想要实现的附加功能代码
然后再通过被声明的成员变量调用真实对象的方法
![[Pasted image 20231127181532.png|500]]
## 动态代理
### JDK^[用来代理接口]
JDK动态代理需要被代理的目标列实现接口
它会根据目标类的接口动态的生成代理对象
代理对象和目标对象^[真实类]有相同的接口
#### 步骤
创建代理类对象并给一个有参构造
随后创建一个代理实例,返回值为proxy.newProxyInstance()
根据所需要的返回参数,通过传递过来的target去获取
![[Pasted image 20231127192844.png|500]]
### CGLib^[用来代理普通类]
通过继承被代理的目标类实现代理,所以不需要目标类实现接口
#### 步骤:
导入cglib包
创建普通类,其内有一普通方法
创建代理类并实现MethodInterveptor接口^[拦截器]
实现接口方法,需要拦截器做的事情都使用这个方法去实现
	拿到真实对象
	创建有参构造传递真实对象,方便去调用
定义一个方法生成代理对象
	![[Pasted image 20231128085923.png|400]]
	setcallback为设置回调对象,回调的是实现了methodIntercept的对象
	![[Pasted image 20231128092435.png|500]]